% Group of generalized permutations
classdef Group < handle
    
    properties (GetAccess = public, SetAccess = protected)
        n = [];
        generators = [];
    end
    
    properties (Access = ?qdimsum.Group)
        chain_ = [];
        order_ = []; % java.math.BigInteger
        decomposition_ = [];
        permOrbits_ = [];
        phaseConfiguration_ = [];
    end
        
    methods
        
        function G1 = monomorphism(self, f)
        % Given a monomorphism f: GenPerm -> GenPerm, returns the
        % image f(G). The monomorphism must be able to operate on
        % elements in parallel, given as matrix rows.
            generators1 = f(self.generators);
            G1 = qdimsum.Group(generators1);
            if ~isequal(self.decomposition_, [])
                G1.decomposition_ = cellfun(f, self.decomposition_, 'UniformOutput', false);
            end
            if ~isequal(self.order_, [])
                G1.order_ = self.order_;
            end
        end
        
        function G1 = restrictToOrbit(self, orbit)
            m = length(orbit);
            n = self.n;
            backIndex = zeros(1, n);
            backIndex(orbit) = 1:m;
            computeBackIndex = @(el) sign(el).*backIndex(abs(el));
            generators1 = zeros(0, m);
            for i = 1:self.nGenerators
                g = computeBackIndex(self.generators(i, orbit));
                if ~isequal(g, 1:m)
                    generators1 = [generators1
                                   g];
                end
            end
            G1 = qdimsum.Group(generators1);
        end
        
        function m = nGenerators(self)
        % Returns the number of elements generating this group
            m = size(self.generators, 1);
        end
        
        function self = Group(generators, order)
        % Constructs a generalized permutation group from a list of generators
        %
        % The generators are provided, one per row, in a matrix.
        %
        % For example, the permutation group S_4 is generated by
        % [2 3 4 1; 2 1 3 4]
            self.n = size(generators, 2);
            assert(self.n >= 1, 'The column dimension of generators defines the domain size, cannot be 0');
            self.generators = generators;
            if size(generators, 1) == 0
                self.order_ = java.math.BigInteger(1);
                self.chain_ = qdimsum.group.Term(self.n);
            end
            if nargin > 1
                if ~isa(order, 'java.math.BigInteger')
                    order = java.math.BigInteger(order);
                end
                self.order_ = order;
            end
        end
        
        function d = decomposition(self)
        % Computes a decomposition of the group
        % as a cell array of size m x 1, corresponding
        % to sets U_1, ..., U_m, so that every group element
        % is uniquely written as u_1 * u_2 * ... u_m and
        % u_i \in U_i
        %
        % The sets U_i are provided as matrices, where
        % each row is a group element
            if isequal(self.decomposition_, [])
                self.decomposition_ = self.chain.groupDecomposition;
            end
            d = self.decomposition_;
        end
        
        function c = chain(self)
        % Returns the group BSGS chain
            if isequal(self.chain_, [])
                if isequal(self.order_, [])
                    self.chain_ = qdimsum.group.Chain.fromGenerators(self.generators);
                else
                    self.chain_ = qdimsum.group.Chain.fromGenerators(self.generators, self.order_);
                end
            end
            c = self.chain_;
        end
        
        
        function r = randomElement(self)
        % Returns a random group element chosen uniformly at random
            r = self.chain.random;
        end
        
        function o = order(self)
        % Returns the order of the group as a java.math.BigInteger
        %
        % use G.order.doubleValue to get a Matlab double
            if isequal(self.order_, [])
                self.order_ = self.chain.order;
            end
            o = self.order_;
        end
        
        function O = permOrbits(self)
        % Returns the orbits of the domain 1:self.n under the group
            if isequal(self.permOrbits_, [])
                self.permOrbits_ = qdimsum.group.Orbits.fromGenPerm(self.generators);
            end
            O = self.permOrbits_;
        end
        
        function P = phaseConfiguration(self)
            if isequal(self.phaseConfiguration_, [])
                self.phaseConfiguration_ = qdimsum.group.PhaseConfiguration.fromGenPerm(self.generators);
            end
            P = self.phaseConfiguration_;
        end
        
    end
    
end
